//    // Setup redis.
//     std::string guestid = QEMU_Guest_ID(ctx); // Returns an UUIDv4.

//     // Maybe a RAII aproach, would solve this tedious "freereplyobject"..
//     rconfirmation = (redisReply *)redisCommand(c1, "SUBSCRIBE qmp-%s ", guestid.c_str());
//     freeReplyObject(rconfirmation);

//     // Start the back-and-forth loop
//     while (redisGetReply(c1, (void **)&rconfirmation) == REDIS_OK)
//     {
//         if (rconfirmation->type == REDIS_REPLY_ARRAY)
//         {
//             std::string str_error;
//             json11::Json jsn = json11::Json::parse(rconfirmation->element[2]->str, str_error);
//             if (!str_error.empty())
//             {
//                 continue;
//             }

//             json11::Json jsn_object = jsn.object_items();
//             std::string command = jsn_object["execute"].string_value();

//             // TODO: intercept and parse json, in reply-str, find "exit" and stuff,
//             std::cout << "Forward to QMP-socket " << rconfirmation->element[2]->str << std::endl;
//             char str[4096];
//             int s = QEMU_OpenQMPSocket(ctx);
//             int t = send(s, rconfirmation->element[2]->str, strlen(rconfirmation->element[2]->str) + 1, 0);
//             sleep(1); // This is a variable point, that needs to be looked at. e-poll?
//             t = recv(s, str, 4096, 0);

//             if (command.compare("system_powerdown") == 0)
//             {
//                 freeReplyObject(rconfirmation);
//                 close(s);
//                 break;
//             }

//             // consume message
//             freeReplyObject(rconfirmation);
//             close(s);
//         }
//     }
//     redisFree(c1);